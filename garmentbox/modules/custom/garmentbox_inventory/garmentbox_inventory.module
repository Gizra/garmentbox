<?php
/**
 * @file
 * Code for the Garmentbox Inventory feature.
 */

include_once 'garmentbox_inventory.features.inc';

define('INVENTORY_TYPE_CURRENT_PRODUCTION', 'Current production');
define('INVENTORY_TYPE_REGULAR_STOCK', 'Regular stock');
define('INVENTORY_TYPE_FUTURE_PRODUCTION', 'Future production');

/**
 * Implements hook_ctools_plugin_directory().
 */
function garmentbox_inventory_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_menu().
 */
function garmentbox_inventory_menu() {
  $items['season/%node/inventory'] = array(
    'title callback' => 'garmentbox_inventory_get_page_title',
    'title arguments' => array(1),
    'page callback' => 'garmentbox_inventory_get_summary',
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
    'access callback' => 'node_access',
    'access arguments' => array('view', 1),
  );

  return $items;
}

/**
 * Build the page title for season inventory page.
 *
 * @param $node
 *   The season node.
 *
 * @return
 *   The title string.
 */
function garmentbox_inventory_get_page_title($node) {
  return t('@season - Inventory', array('@season' => $node->title));
}

/**
 * Implements hook_field_access().
 *
 * Hide date fields from inventory form.
 * TODO: Why do we do that?
 */
function garmentbox_inventory_field_access($op, $field, $entity_type, $entity, $account) {
  if ($op != 'edit') {
    return;
  }

  $field_names = array(
    'field_production_start_date',
    'field_delivery_date',
    'field_inventory_status',
  );
  if (!empty($field['field_name']) && in_array($field['field_name'],$field_names)) {
    return FALSE;
  }
}

/**
 * Implements hook_entity_info_alter().
 *
 * Add the controller information on the entity. Note that you can also
 * add the controller on the bundle level.
 */
function garmentbox_inventory_entity_info_alter(&$entity_info) {
  $entity_info['node']['bundles']['inventory_line']['inline entity form'] = array(
    'controller' => 'NodeInventoryLineInlineEntityFormController',
  );
}


/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Order form.
 */
function garmentbox_inventory_form_order_node_form_alter(&$form, $form_state) {
  $subform = &$form['field_inventory_line_inline'][LANGUAGE_NONE]['form'];

  // _garmentbox_inventory_form_hide_fields($subform, $form_state);
  _garmentbox_inventory_form_saleble_inventory_type($subform, $form_state);
  _garmentbox_inventory_form_price($form, $form_state);
}

/**
 * Hide all fields if Item variant is not selected.
 */
function _garmentbox_inventory_form_hide_fields(&$form, $form_state) {
  $elements = array(
    'field_quantity_info',
    'field_inventory_type',
    'field_price',
    'actions',
  );

  $states = array(
    '#states' => array(
      'invisible' => array(
        ':input[name="field_inventory_line_inline[und][form][field_item_variant][und]"]' => array('value' => '_none'),
      ),
    ),
  );

  foreach ($elements as $element) {
    $form[$element] += $states;
  }
}


/**
 * Show only "In warehouse" inventory type.
 */
function _garmentbox_inventory_form_saleble_inventory_type(&$form, $form_state) {
  $tids = $form['field_inventory_type'][LANGUAGE_NONE]['#options'];
  unset($tids['_none']);

  $terms = taxonomy_term_load_multiple(array_keys($tids));
  foreach ($terms as $term) {
    $wrapper = entity_metadata_wrapper('taxonomy_term', $term);
    if (!$wrapper->field_in_warehouse->value()) {
      unset($form['field_inventory_type'][LANGUAGE_NONE]['#options'][$term->tid]);
    }
  }
}


/**
 * Set the price field to required and add calcualted price.
 */
function _garmentbox_inventory_form_price(&$form, $form_state) {
}

function garmentbox_inventory_is_inventory_item_ordered($nid) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'order')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_inventory_line_inline', 'target_id', $nid)
    ->range(0, 1)
    ->execute();

  return !empty($result);
}

/**
 * Show the inventory of a season or item.
 *
 * @param $node
 *   Season or item node.
 *
 * @return
 *   Rendered table with inventory info.
 */
function garmentbox_inventory_get_summary($node) {
  $empty_message = t('No inventory created yet.');

  $item_nids = array();
  if ($node->type == 'item') {
    $item_nids = array($node->nid);
  }
  else {
    // Get all the items that belong to the season.
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'node')
      ->propertyCondition('type', 'item')
      ->propertyCondition('status', NODE_PUBLISHED)
      ->fieldCondition('field_season', 'target_id', $node->nid)
      ->execute();

    if (empty($result['node'])) {
      return $empty_message;
    }

    $item_nids = array_keys($result['node']);
  }

  // Build an array of inventory types, keyed by TID. Specifying whether the
  // type should be included in "totals".
  // "Defective" isn't really a type, but we show it as one.
  $excluded_inventory_types = array(t('Defective'));
  $vocab = taxonomy_vocabulary_machine_name_load('inventory_type');
  foreach (taxonomy_get_tree($vocab->vid, 0, NULL, TRUE) as $term) {
    $wrapper = entity_metadata_wrapper('taxonomy_term', $term);
    $inventory_types[$term->tid] = array(
      'include_in_total' => $wrapper->field_include_in_total->value(),
    );
    if (!$wrapper->field_include_in_total->value()) {
      $excluded_inventory_types[] = $wrapper->label();
    }
  }

  $total_type_label = t('All types');
  if ($excluded_inventory_types) {
    $total_type_label .= t('<span class="minor">Except of @types.</span>', array('@types' => implode(', ', $excluded_inventory_types)));
  }

  $header = $rows = array();
  $header['item variant'] = t('Variation');

  $vocab = taxonomy_vocabulary_machine_name_load('size');
  $size_tree = taxonomy_get_tree($vocab->vid);
  foreach ($size_tree as $term) {
    $header[$term->tid] = $term->name;
  }

  $header['type'] = t('Type');

  // Get all the item variants that belong to the items.
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'item_variant')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_item', 'target_id', $item_nids, 'IN')
    ->execute();

  if (empty($result['node'])) {
    return $empty_message;
  }

  // Get all the inventory lines that belong to the item variants.
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'inventory_line')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_item_variant', 'target_id', array_keys($result['node']), 'IN')
    ->fieldOrderBy('field_item_variant', 'target_id')
    ->execute();

  if (empty($result['node'])) {
    return $empty_message;
  }

  drupal_add_js(drupal_get_path('module', 'garmentbox_inventory') . '/inventory_summary.js');

  // Build inventory data info, keyed by the inventory item type TID.
  $inventory = array();
  $inventory_nodes = node_load_multiple(array_keys($result['node']));
  foreach($inventory_nodes as $inventory_node) {
    $wrapper = entity_metadata_wrapper('node', $inventory_node);
    $tid = $wrapper->field_inventory_type->getIdentifier();

    $defective = $wrapper->field_defective->value();
    // Determine if we need to add or subtract the quantity from the total
    // calcualtion.
    $in_warehouse = $wrapper->field_inventory_type->field_in_warehouse->value();

    $nid = $wrapper->field_item_variant->getIdentifier();

    // Don't affect the total with excluded inventory types, nor with defective
    // inventory lines.
    $include_in_total = $inventory_types[$tid]['include_in_total'] && !$defective;

    $inventory[$nid]['label'] = $wrapper->field_item_variant->label();
    if (!$defective) {
      $type_key = $tid;
      $inventory[$nid]['types'][$type_key]['type_label'] = $wrapper->field_inventory_type->label();
      $inventory[$nid]['types'][$type_key]['in_total'] = $include_in_total;
    }
    else {
      $type_key = 'defective';
      $inventory[$nid]['types'][$type_key]['type_label'] = t('Defective');
      $inventory[$nid]['types'][$type_key]['in_total'] = FALSE;
    }

    foreach ($size_tree as $term) {
      $inventory[$nid]['total'][$term->tid]['available'] = !empty($inventory[$nid]['total'][$term->tid]['available']) ? $inventory[$nid]['total'][$term->tid]['available'] : 0;
      $inventory[$nid]['total'][$term->tid]['ordered'] = !empty($inventory[$nid]['total'][$term->tid]['ordered']) ? $inventory[$nid]['total'][$term->tid]['ordered'] : 0;
      $inventory[$nid]['total'][$term->tid]['future_stock'] = !empty($inventory[$nid]['total'][$term->tid]['future_stock']) ? $inventory[$nid]['total'][$term->tid]['future_stock'] : 0;
      $inventory[$nid]['total'][$term->tid]['quantity'] = !empty($inventory[$nid]['total'][$term->tid]['quantity']) ? $inventory[$nid]['total'][$term->tid]['quantity'] : 0;
    }

    $is_ordered = garmentbox_inventory_is_inventory_item_ordered($inventory_node->nid);

    foreach ($wrapper->field_quantity_info as $quantity_wrapper) {
      $size_tid = $quantity_wrapper->field_size->getIdentifier();
      $info = !empty($inventory[$nid]['types'][$type_key]['data'][$size_tid]) ? $inventory[$nid]['types'][$type_key]['data'][$size_tid] : array();
      $info['quantity'] = !empty($info['quantity']) ? $info['quantity'] : 0;
      $info['ordered'] = !empty($info['ordered']) ? $info['ordered'] : 0;

      $quantity = $quantity_wrapper->field_quantity_integer->value();

      $info['quantity'] += $quantity;
      if ($is_ordered) {
        $info['ordered'] += $quantity;
      }
      $inventory[$nid]['types'][$type_key]['data'][$size_tid] = $info;

      // Quantity - Inventory line with stock type marked as “in warehouse” and
      // both ordered and not ordered (also could be Available + ordered).
      // Available (green) - This is stock NOT ordered marked as in warehouse.
      // Ordered (blue)(used to available) - This is ordered stock in status
      // marked as in warehouse. + Ordered-future.
      // Ordered-future (red)- This is a sum of ordered inventory lines in
      // status marked as NOT in warehouse deducted from sum of all inventory
      // line with not in warehouse and no order.
      // Future stock - Sum not in warehouse and No order.
      if ($in_warehouse) {
        $inventory[$nid]['total'][$size_tid]['quantity'] += $include_in_total ? $quantity : 0;

        if ($is_ordered) {
          $inventory[$nid]['total'][$size_tid]['ordered'] += $include_in_total ? $quantity : 0;
        }
        else {
          $inventory[$nid]['total'][$size_tid]['available'] += $include_in_total ? $quantity : 0;
        }
      }
      else {
        if ($is_ordered) {
          $inventory[$nid]['total'][$size_tid]['ordered'] += $include_in_total ? $quantity : 0;
        }
        else {
          $inventory[$nid]['total'][$size_tid]['future_stock'] += $include_in_total ? $quantity : 0;
        }
      }
    }
  }

  // Build the output based on the inventory data info.
  foreach ($inventory as $nid => $variant_data) {

    $items = array();
    $variant_label = $variant_data['label'];

    // Variant total row.
    $row = array(
      'data' => array(),
      'class' => array('expandable'),
      'variant-nid' => $nid,
    );
    $params = array(
      'attributes' => array(
        'class' => array('expander', 'collapsed'),
      )
    );
    $expand_link = l('', url(''), $params);
    $row['data'][] = $expand_link . t('@variant - Total', array('@variant' => $variant_label));
    foreach($size_tree as $term) {
      $row['data'][] = theme('garmentbox_inventory_cell', $variant_data['total'][$term->tid] + array('quantity_title' => t('Stock')));
    }

    // Total row description.
    $row['data'][] = $total_type_label;

    $rows[] = $row;

    foreach ($variant_data['types'] as $variant_inventory_data) {
      if (empty($variant_inventory_data['data'])) {
        // There are no values for this inventory type.
        continue;
      }
      $row = array(
        'data' => array(),
        'class' => array('type', 'hidden', 'variant-nid-' . $nid),
      );

      // Add a class specifying that the row is included in the total, to enable
      // highlighting it when the total is hovered.
      if ($variant_inventory_data['in_total']) {
        $row['class'][] = 'in-total';
      }

      $row['data'][] = $variant_label;

      foreach($size_tree as $term) {
        if (empty($variant_inventory_data['data'][$term->tid])) {
          $row['data'][] = theme('garmentbox_inventory_cell', array('quantity' => 0));
          continue;
        }

        $row['data'][] = theme('garmentbox_inventory_cell', $variant_inventory_data['data'][$term->tid]);
      }
      $row['data'][] = $variant_inventory_data['type_label'];
      $rows[] = $row;
    }
  }

  $variables = array(
    'header' => $header,
    'rows' => $rows,
    'attributes' => array(
      'id' => 'inventory-summary',
    ),
  );
  return theme('table', $variables);
}

/**
 * Delegated hook_theme().
 */
function garmentbox_inventory_theme($existing, $type, $theme, $path) {
  return array(
    'garmentbox_inventory_cell' => array(
      'variables' => array(
        'quantity' => NULL,
        'available' => NULL,
        'ordered' => NULL,
        'future_stock' => NULL,
        'label' => NULL,
        'class' => NULL,
        'quantity_title' => NULL,
        'subfigure_types' => array(
          'available' => t('Available'),
          'ordered' => t('Ordered'),
          'future_stock' => t('Future stock'),
        ),
      ),
      'template' => 'inventory-summary-cell',
    ),
  );
}
