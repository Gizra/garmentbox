<?php
/**
 * @file
 * Code for the Garmentbox Inventory feature.
 */

include_once 'garmentbox_inventory.features.inc';

define('INVENTORY_TYPE_CURRENT_PRODUCTION', 'Current production');
define('INVENTORY_TYPE_REGULAR_STOCK', 'Regular stock');
define('INVENTORY_TYPE_FUTURE_PRODUCTION', 'Future production');

/**
 * Implements hook_ctools_plugin_directory().
 */
function garmentbox_inventory_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_menu().
 */
function garmentbox_inventory_menu() {
  $items['season/%node/inventory'] = array(
    'title callback' => 'garmentbox_inventory_get_page_title',
    'title arguments' => array(1),
    'page callback' => 'garmentbox_inventory_get_summary',
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
    'access callback' => 'node_access',
    'access arguments' => array('view', 1),
  );

  return $items;
}

/**
 * Build the page title for season inventory page.
 *
 * @param $node
 *   The season node.
 *
 * @return
 *   The title string.
 */
function garmentbox_inventory_get_page_title($node) {
  return t('@season - Inventory', array('@season' => $node->title));
}

/**
 * Implements hook_field_access().
 *
 * Hide date fields from inventory form.
 * TODO: Why do we do that?
 */
function garmentbox_inventory_field_access($op, $field, $entity_type, $entity, $account) {
  if ($op != 'edit') {
    return;
  }

  $field_names = array(
    'field_production_start_date',
    'field_delivery_date',
    'field_inventory_status',
  );
  if (!empty($field['field_name']) && in_array($field['field_name'],$field_names)) {
    return FALSE;
  }
}

/**
 * Implements hook_entity_info_alter().
 *
 * Add the controller information on the entity. Note that you can also
 * add the controller on the bundle level.
 */
function garmentbox_inventory_entity_info_alter(&$entity_info) {
  $entity_info['node']['bundles']['inventory_line']['inline entity form'] = array(
    'controller' => 'NodeInventoryLineInlineEntityFormController',
  );
}


/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Order form.
 */
function garmentbox_inventory_form_order_node_form_alter(&$form, $form_state) {
  $subform = &$form['field_inventory_line_inline'][LANGUAGE_NONE]['form'];

  // _garmentbox_inventory_form_hide_fields($subform, $form_state);
  _garmentbox_inventory_form_saleble_inventory_type($subform, $form_state);
  _garmentbox_inventory_form_price($form, $form_state);
}

/**
 * Hide all fields if Item variant is not selected.
 */
function _garmentbox_inventory_form_hide_fields(&$form, $form_state) {
  $elements = array(
    'field_quantity_info',
    'field_inventory_type',
    'field_price',
    'actions',
  );

  $states = array(
    '#states' => array(
      'invisible' => array(
        ':input[name="field_inventory_line_inline[und][form][field_item_variant][und]"]' => array('value' => '_none'),
      ),
    ),
  );

  foreach ($elements as $element) {
    $form[$element] += $states;
  }
}


/**
 * Show only "In warehouse" inventory type.
 */
function _garmentbox_inventory_form_saleble_inventory_type(&$form, $form_state) {
  $tids = $form['field_inventory_type'][LANGUAGE_NONE]['#options'];
  unset($tids['_none']);

  $terms = taxonomy_term_load_multiple(array_keys($tids));
  foreach ($terms as $term) {
    $wrapper = entity_metadata_wrapper('taxonomy_term', $term);
    if (!$wrapper->field_in_warehouse->value()) {
      unset($form['field_inventory_type'][LANGUAGE_NONE]['#options'][$term->tid]);
    }
  }
}


/**
 * Set the price field to required and add calcualted price.
 */
function _garmentbox_inventory_form_price(&$form, $form_state) {
}

function garmentbox_inventory_is_inventory_item_ordered($nid) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'order')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_inventory_line_inline', 'target_id', $nid)
    ->range(0, 1)
    ->execute();

  return !empty($result);
}

/**
 * Show the inventory of a season or item.
 *
 * @param $node
 *   Season or item node.
 *
 * @return
 *   Rendered table with inventory info.
 */
function garmentbox_inventory_get_summary($node) {
  $empty_message = t('No inventory created yet.');

  $item_nids = array();
  if ($node->type == 'item') {
    $item_nids = array($node->nid);
  }
  else {
    // Get all the items that belong to the season.
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'node')
      ->propertyCondition('type', 'item')
      ->propertyCondition('status', NODE_PUBLISHED)
      ->fieldCondition('field_season', 'target_id', $node->nid)
      ->execute();

    if (empty($result['node'])) {
      return $empty_message;
    }

    $item_nids = array_keys($result['node']);
  }

  // Build an array of inventory types, keyed by TID. Specifying whether the
  // type should be included in "totals".
  // "Defective" isn't really a type, but we show it as one.
  $excluded_inventory_types = array(t('Defective'));
  $vocab = taxonomy_vocabulary_machine_name_load('inventory_type');
  foreach (taxonomy_get_tree($vocab->vid, 0, NULL, TRUE) as $term) {
    $wrapper = entity_metadata_wrapper('taxonomy_term', $term);
    $inventory_types[$term->tid] = array(
      'include_in_total' => $wrapper->field_include_in_total->value(),
    );
    if (!$wrapper->field_include_in_total->value()) {
      $excluded_inventory_types[] = $wrapper->label();
    }
  }

  $total_type_label = t('All types');
  if ($excluded_inventory_types) {
    $total_type_label .= t('<span class="minor">Except of @types.</span>', array('@types' => implode(', ', $excluded_inventory_types)));
  }

  $header = $rows = array();
  $header['item variant'] = t('Variation');

  $vocab = taxonomy_vocabulary_machine_name_load('size');
  $size_tree = taxonomy_get_tree($vocab->vid);
  foreach ($size_tree as $term) {
    $header[$term->tid] = $term->name;
  }

  $header['type'] = t('Type');

  // Get all the item variants that belong to the items.
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'item_variant')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_item', 'target_id', $item_nids, 'IN')
    ->execute();

  if (empty($result['node'])) {
    return $empty_message;
  }

  // Get all the inventory lines that belong to the item variants.
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'inventory_line')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_item_variant', 'target_id', array_keys($result['node']), 'IN')
    ->fieldOrderBy('field_item_variant', 'target_id')
    ->execute();

  if (empty($result['node'])) {
    return $empty_message;
  }

  drupal_add_js(drupal_get_path('module', 'garmentbox_inventory') . '/inventory_summary.js');

  // Keep track of the largest number of characters in amount display.
  $main_box_width = 1;

  // Build inventory data info, keyed by the inventory item type TID.
  $inventory = array();
  $inventory_nodes = node_load_multiple(array_keys($result['node']));
  foreach($inventory_nodes as $inventory_node) {
    $wrapper = entity_metadata_wrapper('node', $inventory_node);
    $tid = $wrapper->field_inventory_type->getIdentifier();

    $defective = $wrapper->field_defective->value();
    // Determine if we need to add or subtract the quantity from the total
    // calcualtion.
    $in_warehouse = $wrapper->field_inventory_type->field_in_warehouse->value();

    $nid = $wrapper->field_item_variant->getIdentifier();

    // Don't affect the total with excluded inventory types, nor with defective
    // inventory lines.
    $include_in_total = $inventory_types[$tid]['include_in_total'] && !$defective;

    $is_closed = $wrapper->field_inventory_type->field_closed_stock->value() && !$defective;

    $inventory[$nid]['label'] = $wrapper->field_item_variant->label();
    if (!$defective) {
      $type_key = $tid;
      $inventory[$nid]['types'][$type_key]['type_label'] = $wrapper->field_inventory_type->label();
      $inventory[$nid]['types'][$type_key]['in_total'] = $include_in_total;
      $inventory[$nid]['types'][$type_key]['in_warehouse'] = $in_warehouse  && !$defective;
      $inventory[$nid]['types'][$type_key]['closed'] = FALSE;
    }
    else {
      $type_key = 'defective';
      $inventory[$nid]['types'][$type_key]['type_label'] = t('Defective');
      $inventory[$nid]['types'][$type_key]['in_total'] = FALSE;
      $inventory[$nid]['types'][$type_key]['in_warehouse'] = FALSE;
      $inventory[$nid]['types'][$type_key]['closed'] = TRUE;
    }

    foreach ($size_tree as $term) {
      // Subfigures.
      $inventory[$nid]['total'][$term->tid]['ordered'] = !empty($inventory[$nid]['total'][$term->tid]['ordered']) ? $inventory[$nid]['total'][$term->tid]['ordered'] : 0;
      $inventory[$nid]['total'][$term->tid]['future_stock'] = !empty($inventory[$nid]['total'][$term->tid]['future_stock']) ? $inventory[$nid]['total'][$term->tid]['future_stock'] : 0;
      $inventory[$nid]['total'][$term->tid]['quantity'] = !empty($inventory[$nid]['total'][$term->tid]['quantity']) ? $inventory[$nid]['total'][$term->tid]['quantity'] : 0;
      // Hides the subfigures' boxes if they are all 0.
      $inventory[$nid]['total'][$term->tid]['has_subfigures'] = max($inventory[$nid]['total'][$term->tid]) !== 0;

      // Main figure.
      $inventory[$nid]['total'][$term->tid]['available'] = !empty($inventory[$nid]['total'][$term->tid]['available']) ? $inventory[$nid]['total'][$term->tid]['available'] : 0;
    }


    $is_ordered = garmentbox_inventory_is_inventory_item_ordered($inventory_node->nid);

    foreach ($wrapper->field_quantity_info as $quantity_wrapper) {
      $size_tid = $quantity_wrapper->field_size->getIdentifier();
      $info = !empty($inventory[$nid]['types'][$type_key]['data'][$size_tid]) ? $inventory[$nid]['types'][$type_key]['data'][$size_tid] : array();
      $info['quantity'] = !empty($info['quantity']) ? $info['quantity'] : 0;
      $info['ordered'] = !empty($info['ordered']) ? $info['ordered'] : 0;

      $quantity = $quantity_wrapper->field_quantity_integer->value();
      $main_box_width = max(array($main_box_width, strlen($quantity)));

      $info['quantity'] += $quantity;
      if ($is_ordered) {
        $info['ordered'] += $quantity;
      }
      $inventory[$nid]['types'][$type_key]['data'][$size_tid] = $info;

      // Quantity - Inventory line with stock type marked as “in warehouse” and
      // both ordered and not ordered (also could be Available + ordered).
      // Available (green) - This is stock NOT ordered marked as in warehouse.
      // Ordered (blue)(used to available) - This is ordered stock in status
      // marked as in warehouse. + Ordered-future.
      // Ordered-future (red)- This is a sum of ordered inventory lines in
      // status marked as NOT in warehouse deducted from sum of all inventory
      // line with not in warehouse and no order.
      // Future stock - Sum not in warehouse and No order.
      if ($in_warehouse) {
        $inventory[$nid]['total'][$size_tid]['quantity'] += $include_in_total ? $quantity : 0;

        if ($is_ordered) {
          $inventory[$nid]['total'][$size_tid]['ordered'] += $include_in_total ? $quantity : 0;
        }
        else {
          $inventory[$nid]['total'][$size_tid]['available'] += $include_in_total ? $quantity : 0;
        }
      }
      else {
        if ($is_ordered) {
          $inventory[$nid]['total'][$size_tid]['ordered'] += $include_in_total ? $quantity : 0;
        }
        else {
          $inventory[$nid]['total'][$size_tid]['future_stock'] += $include_in_total ? $quantity : 0;
        }
      }
    }
  }

  // Keep track of the maximum number of characters in variants inventory type
  // amounts.
  $size_amount_width = 2;
  // Build the output based on the inventory data info.
  foreach ($inventory as $nid => $variant_data) {
    $items = array();
    $variant_label = $variant_data['label'];

    // Variant total row.
    $row = array(
      'data' => array(),
      'class' => array('expandable'),
      'variant-nid' => $nid,
    );
    $params = array(
      'attributes' => array(
        'class' => array('expander', 'collapsed'),
      ),
    );
    $expand_link = l('', url(''), $params);
    $row['data'][] = array('data' => $expand_link . t('@variant - Total', array('@variant' => $variant_label)), 'class' => array('variant-type-name'));

    foreach($size_tree as $term) {
      $row['data'][] = theme('garmentbox_inventory_cell', $variant_data['total'][$term->tid]);
    }

    // Total row description.
    $row['data'][] = array('data' => $total_type_label, 'class' => array('variant-status-title'));

    $rows[] = $row;

    foreach ($variant_data['types'] as $variant_inventory_data) {
      if (empty($variant_inventory_data['data'])) {
        // There are no values for this inventory type.
        continue;
      }
      // Add a class specifying the color of quantity boxes in that row.
      $subscell_class = _garmentbox_inventory_subcell_class($variant_inventory_data);

      $row = array(
        'data' => array(),
        'class' => array('variant-status-type', 'type', 'hidden', 'variant-nid-' . $nid, $subscell_class),
      );


      $row['data'][] = '';

      foreach($size_tree as $term) {
        if (empty($variant_inventory_data['data'][$term->tid])) {
          $row['data'][] = theme('garmentbox_inventory_sub_cell', array('quantity' => 0, 'class' => $subscell_class));
          continue;
        }

        // See that we always use the correct size for the boxes.
        $size_amount_width = max(array($size_amount_width, strlen(max($variant_inventory_data['data'][$term->tid]))));
        $row['data'][] = theme('garmentbox_inventory_sub_cell', $variant_inventory_data['data'][$term->tid]);
      }
      $row['data'][] = array('data' => $variant_inventory_data['type_label'], 'class' => array('variant-status-title'));
      $rows[] = $row;
    }
  }

  $variables = array(
    'header' => $header,
    'rows' => $rows,
    'attributes' => array(
      'id' => 'inventory-summary',
      'class' => array('main-box-width-' . $main_box_width, 'size-amount-width-' . $size_amount_width),
    ),
  );
  return theme('table', $variables);
}

/**
 * Get the correct class to add to a row of variant status display.
 *
 * @param @variables
 *   Array containing order status term variables.
 *
 * @return
 *   String; Class to add.
 */
function _garmentbox_inventory_subcell_class($variables) {
  // Make relevant variables more accessible.
  $total = $variables['in_total'];
  $warehouse = $variables['in_warehouse'];
  $closed = $variables['closed'];

  if ($total) {
    // Included in total.

    if(!$warehouse && !$closed) {
      // Included in total but not in the warehouse (yet) and not closed.
      return 'future';
    }

    if ($closed xor $warehouse) {
      // Either closed OR in the warehouse.
      // If both, the item is irrelevant.
      return 'current';
    }
  }

  // All other options.
  return 'irrelevant';
}

/**
 * Delegated hook_theme().
 */
function garmentbox_inventory_theme($existing, $type, $theme, $path) {
  return array(
    'garmentbox_inventory_cell' => array(
      'variables' => array(
        'quantity' => NULL,
        'available' => NULL,
        'ordered' => NULL,
        'future_stock' => NULL,
        'label' => NULL,
        'class' => NULL,
        'quantity_title' => NULL,
        'has_subfigures' => FALSE,
        'subfigure_types' => array(
          'quantity' => t('in stock'),
          'ordered' => t('ordered'),
          'future_stock' => t('future'),
        ),
      ),
      'template' => 'templates/inventory-summary-cell',
    ),
    'garmentbox_inventory_sub_cell' => array(
      'variables' => array(
        'ordered' => NULL,
        'quantity' => NULL,
        'class' => NULL,
      ),
      'template' => 'templates/inventory-summary-sub-cell',
    ),
  );
}
